// Generated by ProtoGen, Version=2.4.1.521, Culture=neutral, PublicKeyToken=55f7125234beb589.  DO NOT EDIT!
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.ProtocolBuffers;
using pbc = global::Google.ProtocolBuffers.Collections;
using pbd = global::Google.ProtocolBuffers.Descriptors;
using scg = global::System.Collections.Generic;
namespace dke.tradesim.protobuf {
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public static partial class Tradesim {
  
    #region Extension registration
    public static void RegisterAllExtensions(pb::ExtensionRegistry registry) {
    }
    #endregion
    #region Static variables
    internal static pbd::MessageDescriptor internal__static_dke_tradesim_protobuf_TransactionLog__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::dke.tradesim.protobuf.TransactionLog, global::dke.tradesim.protobuf.TransactionLog.Builder> internal__static_dke_tradesim_protobuf_TransactionLog__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_dke_tradesim_protobuf_Transaction__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::dke.tradesim.protobuf.Transaction, global::dke.tradesim.protobuf.Transaction.Builder> internal__static_dke_tradesim_protobuf_Transaction__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_dke_tradesim_protobuf_Order__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::dke.tradesim.protobuf.Order, global::dke.tradesim.protobuf.Order.Builder> internal__static_dke_tradesim_protobuf_Order__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_dke_tradesim_protobuf_SplitAdjustment__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::dke.tradesim.protobuf.SplitAdjustment, global::dke.tradesim.protobuf.SplitAdjustment.Builder> internal__static_dke_tradesim_protobuf_SplitAdjustment__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_dke_tradesim_protobuf_CashDividendPayment__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::dke.tradesim.protobuf.CashDividendPayment, global::dke.tradesim.protobuf.CashDividendPayment.Builder> internal__static_dke_tradesim_protobuf_CashDividendPayment__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_dke_tradesim_protobuf_PortfolioValueLog__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::dke.tradesim.protobuf.PortfolioValueLog, global::dke.tradesim.protobuf.PortfolioValueLog.Builder> internal__static_dke_tradesim_protobuf_PortfolioValueLog__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_dke_tradesim_protobuf_PortfolioValue__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::dke.tradesim.protobuf.PortfolioValue, global::dke.tradesim.protobuf.PortfolioValue.Builder> internal__static_dke_tradesim_protobuf_PortfolioValue__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_dke_tradesim_protobuf_FinancialStatement__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::dke.tradesim.protobuf.FinancialStatement, global::dke.tradesim.protobuf.FinancialStatement.Builder> internal__static_dke_tradesim_protobuf_FinancialStatement__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_dke_tradesim_protobuf_StatementLineItem__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::dke.tradesim.protobuf.StatementLineItem, global::dke.tradesim.protobuf.StatementLineItem.Builder> internal__static_dke_tradesim_protobuf_StatementLineItem__FieldAccessorTable;
    #endregion
    #region Descriptor
    public static pbd::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbd::FileDescriptor descriptor;
    
    static Tradesim() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          "Cg50cmFkZXNpbS5wcm90bxIVZGtlLnRyYWRlc2ltLnByb3RvYnVmIkoKDlRy" + 
          "YW5zYWN0aW9uTG9nEjgKDHRyYW5zYWN0aW9ucxgBIAMoCzIiLmRrZS50cmFk" + 
          "ZXNpbS5wcm90b2J1Zi5UcmFuc2FjdGlvbiK8AgoLVHJhbnNhY3Rpb24SNQoE" + 
          "dHlwZRgBIAIoDjInLmRrZS50cmFkZXNpbS5wcm90b2J1Zi5UcmFuc2FjdGlv" + 
          "bi5UeXBlEisKBW9yZGVyGAIgASgLMhwuZGtlLnRyYWRlc2ltLnByb3RvYnVm" + 
          "Lk9yZGVyEj8KD3NwbGl0QWRqdXN0bWVudBgDIAEoCzImLmRrZS50cmFkZXNp" + 
          "bS5wcm90b2J1Zi5TcGxpdEFkanVzdG1lbnQSRwoTY2FzaERpdmlkZW5kUGF5" + 
          "bWVudBgEIAEoCzIqLmRrZS50cmFkZXNpbS5wcm90b2J1Zi5DYXNoRGl2aWRl" + 
          "bmRQYXltZW50Ij8KBFR5cGUSCQoFT3JkZXIQABITCg9TcGxpdEFkanVzdG1l" + 
          "bnQQARIXChNDYXNoRGl2aWRlbmRQYXltZW50EAIi0gEKBU9yZGVyEi8KBHR5" + 
          "cGUYASACKA4yIS5ka2UudHJhZGVzaW0ucHJvdG9idWYuT3JkZXIuVHlwZRIM" + 
          "CgR0aW1lGAIgAigDEhIKCnNlY3VyaXR5SWQYAyACKAMSCwoDcXR5GAQgAigD" + 
          "EhEKCWZpbGxQcmljZRgFIAEoCRISCgpsaW1pdFByaWNlGAYgASgJIkIKBFR5" + 
          "cGUSDQoJTWFya2V0QnV5EAASDgoKTWFya2V0U2VsbBABEgwKCExpbWl0QnV5" + 
          "EAISDQoJTGltaXRTZWxsEAMihwEKD1NwbGl0QWRqdXN0bWVudBISCgpzZWN1" + 
          "cml0eUlkGAEgAigDEg4KBmV4RGF0ZRgCIAIoBRINCgVyYXRpbxgDIAIoCRIW" + 
          "Cg5hZGp1c3RtZW50VGltZRgEIAIoAxIVCg1zaGFyZVF0eURlbHRhGAUgAigD" + 
          "EhIKCmNhc2hQYXlvdXQYBiACKAkinwEKE0Nhc2hEaXZpZGVuZFBheW1lbnQS" + 
          "EgoKc2VjdXJpdHlJZBgBIAIoAxIOCgZleERhdGUYAiACKAMSEwoLcGF5YWJs" + 
          "ZURhdGUYAyABKAMSFgoOYW1vdW50UGVyU2hhcmUYBCACKAkSFgoOYWRqdXN0" + 
          "bWVudFRpbWUYBSACKAMSEAoIc2hhcmVRdHkYBiACKAMSDQoFdG90YWwYByAC" + 
          "KAkiUwoRUG9ydGZvbGlvVmFsdWVMb2cSPgoPcG9ydGZvbGlvVmFsdWVzGAEg" + 
          "AygLMiUuZGtlLnRyYWRlc2ltLnByb3RvYnVmLlBvcnRmb2xpb1ZhbHVlIi0K" + 
          "DlBvcnRmb2xpb1ZhbHVlEgwKBHRpbWUYASACKAMSDQoFdmFsdWUYAiACKAki" + 
          "UQoSRmluYW5jaWFsU3RhdGVtZW50EjsKCWxpbmVJdGVtcxgBIAMoCzIoLmRr" + 
          "ZS50cmFkZXNpbS5wcm90b2J1Zi5TdGF0ZW1lbnRMaW5lSXRlbSKTAQoRU3Rh" + 
          "dGVtZW50TGluZUl0ZW0SOwoEdHlwZRgBIAIoDjItLmRrZS50cmFkZXNpbS5w" + 
          "cm90b2J1Zi5TdGF0ZW1lbnRMaW5lSXRlbS5UeXBlEhEKCWF0dHJpYnV0ZRgC" + 
          "IAIoCRINCgV2YWx1ZRgDIAEoCSIfCgRUeXBlEgoKBlN0cmluZxAAEgsKB0Rl" + 
          "Y2ltYWwQAQ==");
      pbd::FileDescriptor.InternalDescriptorAssigner assigner = delegate(pbd::FileDescriptor root) {
        descriptor = root;
        internal__static_dke_tradesim_protobuf_TransactionLog__Descriptor = Descriptor.MessageTypes[0];
        internal__static_dke_tradesim_protobuf_TransactionLog__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::dke.tradesim.protobuf.TransactionLog, global::dke.tradesim.protobuf.TransactionLog.Builder>(internal__static_dke_tradesim_protobuf_TransactionLog__Descriptor,
                new string[] { "Transactions", });
        internal__static_dke_tradesim_protobuf_Transaction__Descriptor = Descriptor.MessageTypes[1];
        internal__static_dke_tradesim_protobuf_Transaction__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::dke.tradesim.protobuf.Transaction, global::dke.tradesim.protobuf.Transaction.Builder>(internal__static_dke_tradesim_protobuf_Transaction__Descriptor,
                new string[] { "Type", "Order", "SplitAdjustment", "CashDividendPayment", });
        internal__static_dke_tradesim_protobuf_Order__Descriptor = Descriptor.MessageTypes[2];
        internal__static_dke_tradesim_protobuf_Order__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::dke.tradesim.protobuf.Order, global::dke.tradesim.protobuf.Order.Builder>(internal__static_dke_tradesim_protobuf_Order__Descriptor,
                new string[] { "Type", "Time", "SecurityId", "Qty", "FillPrice", "LimitPrice", });
        internal__static_dke_tradesim_protobuf_SplitAdjustment__Descriptor = Descriptor.MessageTypes[3];
        internal__static_dke_tradesim_protobuf_SplitAdjustment__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::dke.tradesim.protobuf.SplitAdjustment, global::dke.tradesim.protobuf.SplitAdjustment.Builder>(internal__static_dke_tradesim_protobuf_SplitAdjustment__Descriptor,
                new string[] { "SecurityId", "ExDate", "Ratio", "AdjustmentTime", "ShareQtyDelta", "CashPayout", });
        internal__static_dke_tradesim_protobuf_CashDividendPayment__Descriptor = Descriptor.MessageTypes[4];
        internal__static_dke_tradesim_protobuf_CashDividendPayment__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::dke.tradesim.protobuf.CashDividendPayment, global::dke.tradesim.protobuf.CashDividendPayment.Builder>(internal__static_dke_tradesim_protobuf_CashDividendPayment__Descriptor,
                new string[] { "SecurityId", "ExDate", "PayableDate", "AmountPerShare", "AdjustmentTime", "ShareQty", "Total", });
        internal__static_dke_tradesim_protobuf_PortfolioValueLog__Descriptor = Descriptor.MessageTypes[5];
        internal__static_dke_tradesim_protobuf_PortfolioValueLog__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::dke.tradesim.protobuf.PortfolioValueLog, global::dke.tradesim.protobuf.PortfolioValueLog.Builder>(internal__static_dke_tradesim_protobuf_PortfolioValueLog__Descriptor,
                new string[] { "PortfolioValues", });
        internal__static_dke_tradesim_protobuf_PortfolioValue__Descriptor = Descriptor.MessageTypes[6];
        internal__static_dke_tradesim_protobuf_PortfolioValue__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::dke.tradesim.protobuf.PortfolioValue, global::dke.tradesim.protobuf.PortfolioValue.Builder>(internal__static_dke_tradesim_protobuf_PortfolioValue__Descriptor,
                new string[] { "Time", "Value", });
        internal__static_dke_tradesim_protobuf_FinancialStatement__Descriptor = Descriptor.MessageTypes[7];
        internal__static_dke_tradesim_protobuf_FinancialStatement__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::dke.tradesim.protobuf.FinancialStatement, global::dke.tradesim.protobuf.FinancialStatement.Builder>(internal__static_dke_tradesim_protobuf_FinancialStatement__Descriptor,
                new string[] { "LineItems", });
        internal__static_dke_tradesim_protobuf_StatementLineItem__Descriptor = Descriptor.MessageTypes[8];
        internal__static_dke_tradesim_protobuf_StatementLineItem__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::dke.tradesim.protobuf.StatementLineItem, global::dke.tradesim.protobuf.StatementLineItem.Builder>(internal__static_dke_tradesim_protobuf_StatementLineItem__Descriptor,
                new string[] { "Type", "Attribute", "Value", });
        return null;
      };
      pbd::FileDescriptor.InternalBuildGeneratedFileFrom(descriptorData,
          new pbd::FileDescriptor[] {
          }, assigner);
    }
    #endregion
    
  }
  #region Messages
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class TransactionLog : pb::GeneratedMessage<TransactionLog, TransactionLog.Builder> {
    private TransactionLog() { }
    private static readonly TransactionLog defaultInstance = new TransactionLog().MakeReadOnly();
    private static readonly string[] _transactionLogFieldNames = new string[] { "transactions" };
    private static readonly uint[] _transactionLogFieldTags = new uint[] { 10 };
    public static TransactionLog DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override TransactionLog DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override TransactionLog ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::dke.tradesim.protobuf.Tradesim.internal__static_dke_tradesim_protobuf_TransactionLog__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<TransactionLog, TransactionLog.Builder> InternalFieldAccessors {
      get { return global::dke.tradesim.protobuf.Tradesim.internal__static_dke_tradesim_protobuf_TransactionLog__FieldAccessorTable; }
    }
    
    public const int TransactionsFieldNumber = 1;
    private pbc::PopsicleList<global::dke.tradesim.protobuf.Transaction> transactions_ = new pbc::PopsicleList<global::dke.tradesim.protobuf.Transaction>();
    public scg::IList<global::dke.tradesim.protobuf.Transaction> TransactionsList {
      get { return transactions_; }
    }
    public int TransactionsCount {
      get { return transactions_.Count; }
    }
    public global::dke.tradesim.protobuf.Transaction GetTransactions(int index) {
      return transactions_[index];
    }
    
    public override bool IsInitialized {
      get {
        foreach (global::dke.tradesim.protobuf.Transaction element in TransactionsList) {
          if (!element.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _transactionLogFieldNames;
      if (transactions_.Count > 0) {
        output.WriteMessageArray(1, field_names[0], transactions_);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        foreach (global::dke.tradesim.protobuf.Transaction element in TransactionsList) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, element);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static TransactionLog ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static TransactionLog ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static TransactionLog ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static TransactionLog ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static TransactionLog ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static TransactionLog ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static TransactionLog ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static TransactionLog ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static TransactionLog ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static TransactionLog ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private TransactionLog MakeReadOnly() {
      transactions_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(TransactionLog prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<TransactionLog, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(TransactionLog cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private TransactionLog result;
      
      private TransactionLog PrepareBuilder() {
        if (resultIsReadOnly) {
          TransactionLog original = result;
          result = new TransactionLog();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override TransactionLog MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::dke.tradesim.protobuf.TransactionLog.Descriptor; }
      }
      
      public override TransactionLog DefaultInstanceForType {
        get { return global::dke.tradesim.protobuf.TransactionLog.DefaultInstance; }
      }
      
      public override TransactionLog BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is TransactionLog) {
          return MergeFrom((TransactionLog) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(TransactionLog other) {
        if (other == global::dke.tradesim.protobuf.TransactionLog.DefaultInstance) return this;
        PrepareBuilder();
        if (other.transactions_.Count != 0) {
          result.transactions_.Add(other.transactions_);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_transactionLogFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _transactionLogFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              input.ReadMessageArray(tag, field_name, result.transactions_, global::dke.tradesim.protobuf.Transaction.DefaultInstance, extensionRegistry);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public pbc::IPopsicleList<global::dke.tradesim.protobuf.Transaction> TransactionsList {
        get { return PrepareBuilder().transactions_; }
      }
      public int TransactionsCount {
        get { return result.TransactionsCount; }
      }
      public global::dke.tradesim.protobuf.Transaction GetTransactions(int index) {
        return result.GetTransactions(index);
      }
      public Builder SetTransactions(int index, global::dke.tradesim.protobuf.Transaction value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.transactions_[index] = value;
        return this;
      }
      public Builder SetTransactions(int index, global::dke.tradesim.protobuf.Transaction.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.transactions_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddTransactions(global::dke.tradesim.protobuf.Transaction value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.transactions_.Add(value);
        return this;
      }
      public Builder AddTransactions(global::dke.tradesim.protobuf.Transaction.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.transactions_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeTransactions(scg::IEnumerable<global::dke.tradesim.protobuf.Transaction> values) {
        PrepareBuilder();
        result.transactions_.Add(values);
        return this;
      }
      public Builder ClearTransactions() {
        PrepareBuilder();
        result.transactions_.Clear();
        return this;
      }
    }
    static TransactionLog() {
      object.ReferenceEquals(global::dke.tradesim.protobuf.Tradesim.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Transaction : pb::GeneratedMessage<Transaction, Transaction.Builder> {
    private Transaction() { }
    private static readonly Transaction defaultInstance = new Transaction().MakeReadOnly();
    private static readonly string[] _transactionFieldNames = new string[] { "cashDividendPayment", "order", "splitAdjustment", "type" };
    private static readonly uint[] _transactionFieldTags = new uint[] { 34, 18, 26, 8 };
    public static Transaction DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Transaction DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Transaction ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::dke.tradesim.protobuf.Tradesim.internal__static_dke_tradesim_protobuf_Transaction__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<Transaction, Transaction.Builder> InternalFieldAccessors {
      get { return global::dke.tradesim.protobuf.Tradesim.internal__static_dke_tradesim_protobuf_Transaction__FieldAccessorTable; }
    }
    
    #region Nested types
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public static partial class Types {
      public enum Type {
        Order = 0,
        SplitAdjustment = 1,
        CashDividendPayment = 2,
      }
      
    }
    #endregion
    
    public const int TypeFieldNumber = 1;
    private bool hasType;
    private global::dke.tradesim.protobuf.Transaction.Types.Type type_ = global::dke.tradesim.protobuf.Transaction.Types.Type.Order;
    public bool HasType {
      get { return hasType; }
    }
    public global::dke.tradesim.protobuf.Transaction.Types.Type Type {
      get { return type_; }
    }
    
    public const int OrderFieldNumber = 2;
    private bool hasOrder;
    private global::dke.tradesim.protobuf.Order order_;
    public bool HasOrder {
      get { return hasOrder; }
    }
    public global::dke.tradesim.protobuf.Order Order {
      get { return order_ ?? global::dke.tradesim.protobuf.Order.DefaultInstance; }
    }
    
    public const int SplitAdjustmentFieldNumber = 3;
    private bool hasSplitAdjustment;
    private global::dke.tradesim.protobuf.SplitAdjustment splitAdjustment_;
    public bool HasSplitAdjustment {
      get { return hasSplitAdjustment; }
    }
    public global::dke.tradesim.protobuf.SplitAdjustment SplitAdjustment {
      get { return splitAdjustment_ ?? global::dke.tradesim.protobuf.SplitAdjustment.DefaultInstance; }
    }
    
    public const int CashDividendPaymentFieldNumber = 4;
    private bool hasCashDividendPayment;
    private global::dke.tradesim.protobuf.CashDividendPayment cashDividendPayment_;
    public bool HasCashDividendPayment {
      get { return hasCashDividendPayment; }
    }
    public global::dke.tradesim.protobuf.CashDividendPayment CashDividendPayment {
      get { return cashDividendPayment_ ?? global::dke.tradesim.protobuf.CashDividendPayment.DefaultInstance; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasType) return false;
        if (HasOrder) {
          if (!Order.IsInitialized) return false;
        }
        if (HasSplitAdjustment) {
          if (!SplitAdjustment.IsInitialized) return false;
        }
        if (HasCashDividendPayment) {
          if (!CashDividendPayment.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _transactionFieldNames;
      if (hasType) {
        output.WriteEnum(1, field_names[3], (int) Type, Type);
      }
      if (hasOrder) {
        output.WriteMessage(2, field_names[1], Order);
      }
      if (hasSplitAdjustment) {
        output.WriteMessage(3, field_names[2], SplitAdjustment);
      }
      if (hasCashDividendPayment) {
        output.WriteMessage(4, field_names[0], CashDividendPayment);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasType) {
          size += pb::CodedOutputStream.ComputeEnumSize(1, (int) Type);
        }
        if (hasOrder) {
          size += pb::CodedOutputStream.ComputeMessageSize(2, Order);
        }
        if (hasSplitAdjustment) {
          size += pb::CodedOutputStream.ComputeMessageSize(3, SplitAdjustment);
        }
        if (hasCashDividendPayment) {
          size += pb::CodedOutputStream.ComputeMessageSize(4, CashDividendPayment);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static Transaction ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Transaction ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Transaction ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Transaction ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Transaction ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Transaction ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Transaction ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Transaction ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Transaction ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Transaction ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Transaction MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Transaction prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<Transaction, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Transaction cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Transaction result;
      
      private Transaction PrepareBuilder() {
        if (resultIsReadOnly) {
          Transaction original = result;
          result = new Transaction();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Transaction MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::dke.tradesim.protobuf.Transaction.Descriptor; }
      }
      
      public override Transaction DefaultInstanceForType {
        get { return global::dke.tradesim.protobuf.Transaction.DefaultInstance; }
      }
      
      public override Transaction BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is Transaction) {
          return MergeFrom((Transaction) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Transaction other) {
        if (other == global::dke.tradesim.protobuf.Transaction.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasType) {
          Type = other.Type;
        }
        if (other.HasOrder) {
          MergeOrder(other.Order);
        }
        if (other.HasSplitAdjustment) {
          MergeSplitAdjustment(other.SplitAdjustment);
        }
        if (other.HasCashDividendPayment) {
          MergeCashDividendPayment(other.CashDividendPayment);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_transactionFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _transactionFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              object unknown;
              if(input.ReadEnum(ref result.type_, out unknown)) {
                result.hasType = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(1, (ulong)(int)unknown);
              }
              break;
            }
            case 18: {
              global::dke.tradesim.protobuf.Order.Builder subBuilder = global::dke.tradesim.protobuf.Order.CreateBuilder();
              if (result.hasOrder) {
                subBuilder.MergeFrom(Order);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Order = subBuilder.BuildPartial();
              break;
            }
            case 26: {
              global::dke.tradesim.protobuf.SplitAdjustment.Builder subBuilder = global::dke.tradesim.protobuf.SplitAdjustment.CreateBuilder();
              if (result.hasSplitAdjustment) {
                subBuilder.MergeFrom(SplitAdjustment);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              SplitAdjustment = subBuilder.BuildPartial();
              break;
            }
            case 34: {
              global::dke.tradesim.protobuf.CashDividendPayment.Builder subBuilder = global::dke.tradesim.protobuf.CashDividendPayment.CreateBuilder();
              if (result.hasCashDividendPayment) {
                subBuilder.MergeFrom(CashDividendPayment);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              CashDividendPayment = subBuilder.BuildPartial();
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasType {
       get { return result.hasType; }
      }
      public global::dke.tradesim.protobuf.Transaction.Types.Type Type {
        get { return result.Type; }
        set { SetType(value); }
      }
      public Builder SetType(global::dke.tradesim.protobuf.Transaction.Types.Type value) {
        PrepareBuilder();
        result.hasType = true;
        result.type_ = value;
        return this;
      }
      public Builder ClearType() {
        PrepareBuilder();
        result.hasType = false;
        result.type_ = global::dke.tradesim.protobuf.Transaction.Types.Type.Order;
        return this;
      }
      
      public bool HasOrder {
       get { return result.hasOrder; }
      }
      public global::dke.tradesim.protobuf.Order Order {
        get { return result.Order; }
        set { SetOrder(value); }
      }
      public Builder SetOrder(global::dke.tradesim.protobuf.Order value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasOrder = true;
        result.order_ = value;
        return this;
      }
      public Builder SetOrder(global::dke.tradesim.protobuf.Order.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasOrder = true;
        result.order_ = builderForValue.Build();
        return this;
      }
      public Builder MergeOrder(global::dke.tradesim.protobuf.Order value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasOrder &&
            result.order_ != global::dke.tradesim.protobuf.Order.DefaultInstance) {
            result.order_ = global::dke.tradesim.protobuf.Order.CreateBuilder(result.order_).MergeFrom(value).BuildPartial();
        } else {
          result.order_ = value;
        }
        result.hasOrder = true;
        return this;
      }
      public Builder ClearOrder() {
        PrepareBuilder();
        result.hasOrder = false;
        result.order_ = null;
        return this;
      }
      
      public bool HasSplitAdjustment {
       get { return result.hasSplitAdjustment; }
      }
      public global::dke.tradesim.protobuf.SplitAdjustment SplitAdjustment {
        get { return result.SplitAdjustment; }
        set { SetSplitAdjustment(value); }
      }
      public Builder SetSplitAdjustment(global::dke.tradesim.protobuf.SplitAdjustment value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasSplitAdjustment = true;
        result.splitAdjustment_ = value;
        return this;
      }
      public Builder SetSplitAdjustment(global::dke.tradesim.protobuf.SplitAdjustment.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasSplitAdjustment = true;
        result.splitAdjustment_ = builderForValue.Build();
        return this;
      }
      public Builder MergeSplitAdjustment(global::dke.tradesim.protobuf.SplitAdjustment value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasSplitAdjustment &&
            result.splitAdjustment_ != global::dke.tradesim.protobuf.SplitAdjustment.DefaultInstance) {
            result.splitAdjustment_ = global::dke.tradesim.protobuf.SplitAdjustment.CreateBuilder(result.splitAdjustment_).MergeFrom(value).BuildPartial();
        } else {
          result.splitAdjustment_ = value;
        }
        result.hasSplitAdjustment = true;
        return this;
      }
      public Builder ClearSplitAdjustment() {
        PrepareBuilder();
        result.hasSplitAdjustment = false;
        result.splitAdjustment_ = null;
        return this;
      }
      
      public bool HasCashDividendPayment {
       get { return result.hasCashDividendPayment; }
      }
      public global::dke.tradesim.protobuf.CashDividendPayment CashDividendPayment {
        get { return result.CashDividendPayment; }
        set { SetCashDividendPayment(value); }
      }
      public Builder SetCashDividendPayment(global::dke.tradesim.protobuf.CashDividendPayment value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasCashDividendPayment = true;
        result.cashDividendPayment_ = value;
        return this;
      }
      public Builder SetCashDividendPayment(global::dke.tradesim.protobuf.CashDividendPayment.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasCashDividendPayment = true;
        result.cashDividendPayment_ = builderForValue.Build();
        return this;
      }
      public Builder MergeCashDividendPayment(global::dke.tradesim.protobuf.CashDividendPayment value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasCashDividendPayment &&
            result.cashDividendPayment_ != global::dke.tradesim.protobuf.CashDividendPayment.DefaultInstance) {
            result.cashDividendPayment_ = global::dke.tradesim.protobuf.CashDividendPayment.CreateBuilder(result.cashDividendPayment_).MergeFrom(value).BuildPartial();
        } else {
          result.cashDividendPayment_ = value;
        }
        result.hasCashDividendPayment = true;
        return this;
      }
      public Builder ClearCashDividendPayment() {
        PrepareBuilder();
        result.hasCashDividendPayment = false;
        result.cashDividendPayment_ = null;
        return this;
      }
    }
    static Transaction() {
      object.ReferenceEquals(global::dke.tradesim.protobuf.Tradesim.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Order : pb::GeneratedMessage<Order, Order.Builder> {
    private Order() { }
    private static readonly Order defaultInstance = new Order().MakeReadOnly();
    private static readonly string[] _orderFieldNames = new string[] { "fillPrice", "limitPrice", "qty", "securityId", "time", "type" };
    private static readonly uint[] _orderFieldTags = new uint[] { 42, 50, 32, 24, 16, 8 };
    public static Order DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Order DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Order ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::dke.tradesim.protobuf.Tradesim.internal__static_dke_tradesim_protobuf_Order__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<Order, Order.Builder> InternalFieldAccessors {
      get { return global::dke.tradesim.protobuf.Tradesim.internal__static_dke_tradesim_protobuf_Order__FieldAccessorTable; }
    }
    
    #region Nested types
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public static partial class Types {
      public enum Type {
        MarketBuy = 0,
        MarketSell = 1,
        LimitBuy = 2,
        LimitSell = 3,
      }
      
    }
    #endregion
    
    public const int TypeFieldNumber = 1;
    private bool hasType;
    private global::dke.tradesim.protobuf.Order.Types.Type type_ = global::dke.tradesim.protobuf.Order.Types.Type.MarketBuy;
    public bool HasType {
      get { return hasType; }
    }
    public global::dke.tradesim.protobuf.Order.Types.Type Type {
      get { return type_; }
    }
    
    public const int TimeFieldNumber = 2;
    private bool hasTime;
    private long time_;
    public bool HasTime {
      get { return hasTime; }
    }
    public long Time {
      get { return time_; }
    }
    
    public const int SecurityIdFieldNumber = 3;
    private bool hasSecurityId;
    private long securityId_;
    public bool HasSecurityId {
      get { return hasSecurityId; }
    }
    public long SecurityId {
      get { return securityId_; }
    }
    
    public const int QtyFieldNumber = 4;
    private bool hasQty;
    private long qty_;
    public bool HasQty {
      get { return hasQty; }
    }
    public long Qty {
      get { return qty_; }
    }
    
    public const int FillPriceFieldNumber = 5;
    private bool hasFillPrice;
    private string fillPrice_ = "";
    public bool HasFillPrice {
      get { return hasFillPrice; }
    }
    public string FillPrice {
      get { return fillPrice_; }
    }
    
    public const int LimitPriceFieldNumber = 6;
    private bool hasLimitPrice;
    private string limitPrice_ = "";
    public bool HasLimitPrice {
      get { return hasLimitPrice; }
    }
    public string LimitPrice {
      get { return limitPrice_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasType) return false;
        if (!hasTime) return false;
        if (!hasSecurityId) return false;
        if (!hasQty) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _orderFieldNames;
      if (hasType) {
        output.WriteEnum(1, field_names[5], (int) Type, Type);
      }
      if (hasTime) {
        output.WriteInt64(2, field_names[4], Time);
      }
      if (hasSecurityId) {
        output.WriteInt64(3, field_names[3], SecurityId);
      }
      if (hasQty) {
        output.WriteInt64(4, field_names[2], Qty);
      }
      if (hasFillPrice) {
        output.WriteString(5, field_names[0], FillPrice);
      }
      if (hasLimitPrice) {
        output.WriteString(6, field_names[1], LimitPrice);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasType) {
          size += pb::CodedOutputStream.ComputeEnumSize(1, (int) Type);
        }
        if (hasTime) {
          size += pb::CodedOutputStream.ComputeInt64Size(2, Time);
        }
        if (hasSecurityId) {
          size += pb::CodedOutputStream.ComputeInt64Size(3, SecurityId);
        }
        if (hasQty) {
          size += pb::CodedOutputStream.ComputeInt64Size(4, Qty);
        }
        if (hasFillPrice) {
          size += pb::CodedOutputStream.ComputeStringSize(5, FillPrice);
        }
        if (hasLimitPrice) {
          size += pb::CodedOutputStream.ComputeStringSize(6, LimitPrice);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static Order ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Order ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Order ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Order ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Order ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Order ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Order ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Order ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Order ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Order ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Order MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Order prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<Order, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Order cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Order result;
      
      private Order PrepareBuilder() {
        if (resultIsReadOnly) {
          Order original = result;
          result = new Order();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Order MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::dke.tradesim.protobuf.Order.Descriptor; }
      }
      
      public override Order DefaultInstanceForType {
        get { return global::dke.tradesim.protobuf.Order.DefaultInstance; }
      }
      
      public override Order BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is Order) {
          return MergeFrom((Order) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Order other) {
        if (other == global::dke.tradesim.protobuf.Order.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasType) {
          Type = other.Type;
        }
        if (other.HasTime) {
          Time = other.Time;
        }
        if (other.HasSecurityId) {
          SecurityId = other.SecurityId;
        }
        if (other.HasQty) {
          Qty = other.Qty;
        }
        if (other.HasFillPrice) {
          FillPrice = other.FillPrice;
        }
        if (other.HasLimitPrice) {
          LimitPrice = other.LimitPrice;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_orderFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _orderFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              object unknown;
              if(input.ReadEnum(ref result.type_, out unknown)) {
                result.hasType = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(1, (ulong)(int)unknown);
              }
              break;
            }
            case 16: {
              result.hasTime = input.ReadInt64(ref result.time_);
              break;
            }
            case 24: {
              result.hasSecurityId = input.ReadInt64(ref result.securityId_);
              break;
            }
            case 32: {
              result.hasQty = input.ReadInt64(ref result.qty_);
              break;
            }
            case 42: {
              result.hasFillPrice = input.ReadString(ref result.fillPrice_);
              break;
            }
            case 50: {
              result.hasLimitPrice = input.ReadString(ref result.limitPrice_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasType {
       get { return result.hasType; }
      }
      public global::dke.tradesim.protobuf.Order.Types.Type Type {
        get { return result.Type; }
        set { SetType(value); }
      }
      public Builder SetType(global::dke.tradesim.protobuf.Order.Types.Type value) {
        PrepareBuilder();
        result.hasType = true;
        result.type_ = value;
        return this;
      }
      public Builder ClearType() {
        PrepareBuilder();
        result.hasType = false;
        result.type_ = global::dke.tradesim.protobuf.Order.Types.Type.MarketBuy;
        return this;
      }
      
      public bool HasTime {
        get { return result.hasTime; }
      }
      public long Time {
        get { return result.Time; }
        set { SetTime(value); }
      }
      public Builder SetTime(long value) {
        PrepareBuilder();
        result.hasTime = true;
        result.time_ = value;
        return this;
      }
      public Builder ClearTime() {
        PrepareBuilder();
        result.hasTime = false;
        result.time_ = 0L;
        return this;
      }
      
      public bool HasSecurityId {
        get { return result.hasSecurityId; }
      }
      public long SecurityId {
        get { return result.SecurityId; }
        set { SetSecurityId(value); }
      }
      public Builder SetSecurityId(long value) {
        PrepareBuilder();
        result.hasSecurityId = true;
        result.securityId_ = value;
        return this;
      }
      public Builder ClearSecurityId() {
        PrepareBuilder();
        result.hasSecurityId = false;
        result.securityId_ = 0L;
        return this;
      }
      
      public bool HasQty {
        get { return result.hasQty; }
      }
      public long Qty {
        get { return result.Qty; }
        set { SetQty(value); }
      }
      public Builder SetQty(long value) {
        PrepareBuilder();
        result.hasQty = true;
        result.qty_ = value;
        return this;
      }
      public Builder ClearQty() {
        PrepareBuilder();
        result.hasQty = false;
        result.qty_ = 0L;
        return this;
      }
      
      public bool HasFillPrice {
        get { return result.hasFillPrice; }
      }
      public string FillPrice {
        get { return result.FillPrice; }
        set { SetFillPrice(value); }
      }
      public Builder SetFillPrice(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasFillPrice = true;
        result.fillPrice_ = value;
        return this;
      }
      public Builder ClearFillPrice() {
        PrepareBuilder();
        result.hasFillPrice = false;
        result.fillPrice_ = "";
        return this;
      }
      
      public bool HasLimitPrice {
        get { return result.hasLimitPrice; }
      }
      public string LimitPrice {
        get { return result.LimitPrice; }
        set { SetLimitPrice(value); }
      }
      public Builder SetLimitPrice(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasLimitPrice = true;
        result.limitPrice_ = value;
        return this;
      }
      public Builder ClearLimitPrice() {
        PrepareBuilder();
        result.hasLimitPrice = false;
        result.limitPrice_ = "";
        return this;
      }
    }
    static Order() {
      object.ReferenceEquals(global::dke.tradesim.protobuf.Tradesim.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class SplitAdjustment : pb::GeneratedMessage<SplitAdjustment, SplitAdjustment.Builder> {
    private SplitAdjustment() { }
    private static readonly SplitAdjustment defaultInstance = new SplitAdjustment().MakeReadOnly();
    private static readonly string[] _splitAdjustmentFieldNames = new string[] { "adjustmentTime", "cashPayout", "exDate", "ratio", "securityId", "shareQtyDelta" };
    private static readonly uint[] _splitAdjustmentFieldTags = new uint[] { 32, 50, 16, 26, 8, 40 };
    public static SplitAdjustment DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override SplitAdjustment DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override SplitAdjustment ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::dke.tradesim.protobuf.Tradesim.internal__static_dke_tradesim_protobuf_SplitAdjustment__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<SplitAdjustment, SplitAdjustment.Builder> InternalFieldAccessors {
      get { return global::dke.tradesim.protobuf.Tradesim.internal__static_dke_tradesim_protobuf_SplitAdjustment__FieldAccessorTable; }
    }
    
    public const int SecurityIdFieldNumber = 1;
    private bool hasSecurityId;
    private long securityId_;
    public bool HasSecurityId {
      get { return hasSecurityId; }
    }
    public long SecurityId {
      get { return securityId_; }
    }
    
    public const int ExDateFieldNumber = 2;
    private bool hasExDate;
    private int exDate_;
    public bool HasExDate {
      get { return hasExDate; }
    }
    public int ExDate {
      get { return exDate_; }
    }
    
    public const int RatioFieldNumber = 3;
    private bool hasRatio;
    private string ratio_ = "";
    public bool HasRatio {
      get { return hasRatio; }
    }
    public string Ratio {
      get { return ratio_; }
    }
    
    public const int AdjustmentTimeFieldNumber = 4;
    private bool hasAdjustmentTime;
    private long adjustmentTime_;
    public bool HasAdjustmentTime {
      get { return hasAdjustmentTime; }
    }
    public long AdjustmentTime {
      get { return adjustmentTime_; }
    }
    
    public const int ShareQtyDeltaFieldNumber = 5;
    private bool hasShareQtyDelta;
    private long shareQtyDelta_;
    public bool HasShareQtyDelta {
      get { return hasShareQtyDelta; }
    }
    public long ShareQtyDelta {
      get { return shareQtyDelta_; }
    }
    
    public const int CashPayoutFieldNumber = 6;
    private bool hasCashPayout;
    private string cashPayout_ = "";
    public bool HasCashPayout {
      get { return hasCashPayout; }
    }
    public string CashPayout {
      get { return cashPayout_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasSecurityId) return false;
        if (!hasExDate) return false;
        if (!hasRatio) return false;
        if (!hasAdjustmentTime) return false;
        if (!hasShareQtyDelta) return false;
        if (!hasCashPayout) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _splitAdjustmentFieldNames;
      if (hasSecurityId) {
        output.WriteInt64(1, field_names[4], SecurityId);
      }
      if (hasExDate) {
        output.WriteInt32(2, field_names[2], ExDate);
      }
      if (hasRatio) {
        output.WriteString(3, field_names[3], Ratio);
      }
      if (hasAdjustmentTime) {
        output.WriteInt64(4, field_names[0], AdjustmentTime);
      }
      if (hasShareQtyDelta) {
        output.WriteInt64(5, field_names[5], ShareQtyDelta);
      }
      if (hasCashPayout) {
        output.WriteString(6, field_names[1], CashPayout);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasSecurityId) {
          size += pb::CodedOutputStream.ComputeInt64Size(1, SecurityId);
        }
        if (hasExDate) {
          size += pb::CodedOutputStream.ComputeInt32Size(2, ExDate);
        }
        if (hasRatio) {
          size += pb::CodedOutputStream.ComputeStringSize(3, Ratio);
        }
        if (hasAdjustmentTime) {
          size += pb::CodedOutputStream.ComputeInt64Size(4, AdjustmentTime);
        }
        if (hasShareQtyDelta) {
          size += pb::CodedOutputStream.ComputeInt64Size(5, ShareQtyDelta);
        }
        if (hasCashPayout) {
          size += pb::CodedOutputStream.ComputeStringSize(6, CashPayout);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static SplitAdjustment ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static SplitAdjustment ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static SplitAdjustment ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static SplitAdjustment ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static SplitAdjustment ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static SplitAdjustment ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static SplitAdjustment ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static SplitAdjustment ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static SplitAdjustment ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static SplitAdjustment ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private SplitAdjustment MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(SplitAdjustment prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<SplitAdjustment, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(SplitAdjustment cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private SplitAdjustment result;
      
      private SplitAdjustment PrepareBuilder() {
        if (resultIsReadOnly) {
          SplitAdjustment original = result;
          result = new SplitAdjustment();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override SplitAdjustment MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::dke.tradesim.protobuf.SplitAdjustment.Descriptor; }
      }
      
      public override SplitAdjustment DefaultInstanceForType {
        get { return global::dke.tradesim.protobuf.SplitAdjustment.DefaultInstance; }
      }
      
      public override SplitAdjustment BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is SplitAdjustment) {
          return MergeFrom((SplitAdjustment) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(SplitAdjustment other) {
        if (other == global::dke.tradesim.protobuf.SplitAdjustment.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasSecurityId) {
          SecurityId = other.SecurityId;
        }
        if (other.HasExDate) {
          ExDate = other.ExDate;
        }
        if (other.HasRatio) {
          Ratio = other.Ratio;
        }
        if (other.HasAdjustmentTime) {
          AdjustmentTime = other.AdjustmentTime;
        }
        if (other.HasShareQtyDelta) {
          ShareQtyDelta = other.ShareQtyDelta;
        }
        if (other.HasCashPayout) {
          CashPayout = other.CashPayout;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_splitAdjustmentFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _splitAdjustmentFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasSecurityId = input.ReadInt64(ref result.securityId_);
              break;
            }
            case 16: {
              result.hasExDate = input.ReadInt32(ref result.exDate_);
              break;
            }
            case 26: {
              result.hasRatio = input.ReadString(ref result.ratio_);
              break;
            }
            case 32: {
              result.hasAdjustmentTime = input.ReadInt64(ref result.adjustmentTime_);
              break;
            }
            case 40: {
              result.hasShareQtyDelta = input.ReadInt64(ref result.shareQtyDelta_);
              break;
            }
            case 50: {
              result.hasCashPayout = input.ReadString(ref result.cashPayout_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasSecurityId {
        get { return result.hasSecurityId; }
      }
      public long SecurityId {
        get { return result.SecurityId; }
        set { SetSecurityId(value); }
      }
      public Builder SetSecurityId(long value) {
        PrepareBuilder();
        result.hasSecurityId = true;
        result.securityId_ = value;
        return this;
      }
      public Builder ClearSecurityId() {
        PrepareBuilder();
        result.hasSecurityId = false;
        result.securityId_ = 0L;
        return this;
      }
      
      public bool HasExDate {
        get { return result.hasExDate; }
      }
      public int ExDate {
        get { return result.ExDate; }
        set { SetExDate(value); }
      }
      public Builder SetExDate(int value) {
        PrepareBuilder();
        result.hasExDate = true;
        result.exDate_ = value;
        return this;
      }
      public Builder ClearExDate() {
        PrepareBuilder();
        result.hasExDate = false;
        result.exDate_ = 0;
        return this;
      }
      
      public bool HasRatio {
        get { return result.hasRatio; }
      }
      public string Ratio {
        get { return result.Ratio; }
        set { SetRatio(value); }
      }
      public Builder SetRatio(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasRatio = true;
        result.ratio_ = value;
        return this;
      }
      public Builder ClearRatio() {
        PrepareBuilder();
        result.hasRatio = false;
        result.ratio_ = "";
        return this;
      }
      
      public bool HasAdjustmentTime {
        get { return result.hasAdjustmentTime; }
      }
      public long AdjustmentTime {
        get { return result.AdjustmentTime; }
        set { SetAdjustmentTime(value); }
      }
      public Builder SetAdjustmentTime(long value) {
        PrepareBuilder();
        result.hasAdjustmentTime = true;
        result.adjustmentTime_ = value;
        return this;
      }
      public Builder ClearAdjustmentTime() {
        PrepareBuilder();
        result.hasAdjustmentTime = false;
        result.adjustmentTime_ = 0L;
        return this;
      }
      
      public bool HasShareQtyDelta {
        get { return result.hasShareQtyDelta; }
      }
      public long ShareQtyDelta {
        get { return result.ShareQtyDelta; }
        set { SetShareQtyDelta(value); }
      }
      public Builder SetShareQtyDelta(long value) {
        PrepareBuilder();
        result.hasShareQtyDelta = true;
        result.shareQtyDelta_ = value;
        return this;
      }
      public Builder ClearShareQtyDelta() {
        PrepareBuilder();
        result.hasShareQtyDelta = false;
        result.shareQtyDelta_ = 0L;
        return this;
      }
      
      public bool HasCashPayout {
        get { return result.hasCashPayout; }
      }
      public string CashPayout {
        get { return result.CashPayout; }
        set { SetCashPayout(value); }
      }
      public Builder SetCashPayout(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasCashPayout = true;
        result.cashPayout_ = value;
        return this;
      }
      public Builder ClearCashPayout() {
        PrepareBuilder();
        result.hasCashPayout = false;
        result.cashPayout_ = "";
        return this;
      }
    }
    static SplitAdjustment() {
      object.ReferenceEquals(global::dke.tradesim.protobuf.Tradesim.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class CashDividendPayment : pb::GeneratedMessage<CashDividendPayment, CashDividendPayment.Builder> {
    private CashDividendPayment() { }
    private static readonly CashDividendPayment defaultInstance = new CashDividendPayment().MakeReadOnly();
    private static readonly string[] _cashDividendPaymentFieldNames = new string[] { "adjustmentTime", "amountPerShare", "exDate", "payableDate", "securityId", "shareQty", "total" };
    private static readonly uint[] _cashDividendPaymentFieldTags = new uint[] { 40, 34, 16, 24, 8, 48, 58 };
    public static CashDividendPayment DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override CashDividendPayment DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override CashDividendPayment ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::dke.tradesim.protobuf.Tradesim.internal__static_dke_tradesim_protobuf_CashDividendPayment__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<CashDividendPayment, CashDividendPayment.Builder> InternalFieldAccessors {
      get { return global::dke.tradesim.protobuf.Tradesim.internal__static_dke_tradesim_protobuf_CashDividendPayment__FieldAccessorTable; }
    }
    
    public const int SecurityIdFieldNumber = 1;
    private bool hasSecurityId;
    private long securityId_;
    public bool HasSecurityId {
      get { return hasSecurityId; }
    }
    public long SecurityId {
      get { return securityId_; }
    }
    
    public const int ExDateFieldNumber = 2;
    private bool hasExDate;
    private long exDate_;
    public bool HasExDate {
      get { return hasExDate; }
    }
    public long ExDate {
      get { return exDate_; }
    }
    
    public const int PayableDateFieldNumber = 3;
    private bool hasPayableDate;
    private long payableDate_;
    public bool HasPayableDate {
      get { return hasPayableDate; }
    }
    public long PayableDate {
      get { return payableDate_; }
    }
    
    public const int AmountPerShareFieldNumber = 4;
    private bool hasAmountPerShare;
    private string amountPerShare_ = "";
    public bool HasAmountPerShare {
      get { return hasAmountPerShare; }
    }
    public string AmountPerShare {
      get { return amountPerShare_; }
    }
    
    public const int AdjustmentTimeFieldNumber = 5;
    private bool hasAdjustmentTime;
    private long adjustmentTime_;
    public bool HasAdjustmentTime {
      get { return hasAdjustmentTime; }
    }
    public long AdjustmentTime {
      get { return adjustmentTime_; }
    }
    
    public const int ShareQtyFieldNumber = 6;
    private bool hasShareQty;
    private long shareQty_;
    public bool HasShareQty {
      get { return hasShareQty; }
    }
    public long ShareQty {
      get { return shareQty_; }
    }
    
    public const int TotalFieldNumber = 7;
    private bool hasTotal;
    private string total_ = "";
    public bool HasTotal {
      get { return hasTotal; }
    }
    public string Total {
      get { return total_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasSecurityId) return false;
        if (!hasExDate) return false;
        if (!hasAmountPerShare) return false;
        if (!hasAdjustmentTime) return false;
        if (!hasShareQty) return false;
        if (!hasTotal) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _cashDividendPaymentFieldNames;
      if (hasSecurityId) {
        output.WriteInt64(1, field_names[4], SecurityId);
      }
      if (hasExDate) {
        output.WriteInt64(2, field_names[2], ExDate);
      }
      if (hasPayableDate) {
        output.WriteInt64(3, field_names[3], PayableDate);
      }
      if (hasAmountPerShare) {
        output.WriteString(4, field_names[1], AmountPerShare);
      }
      if (hasAdjustmentTime) {
        output.WriteInt64(5, field_names[0], AdjustmentTime);
      }
      if (hasShareQty) {
        output.WriteInt64(6, field_names[5], ShareQty);
      }
      if (hasTotal) {
        output.WriteString(7, field_names[6], Total);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasSecurityId) {
          size += pb::CodedOutputStream.ComputeInt64Size(1, SecurityId);
        }
        if (hasExDate) {
          size += pb::CodedOutputStream.ComputeInt64Size(2, ExDate);
        }
        if (hasPayableDate) {
          size += pb::CodedOutputStream.ComputeInt64Size(3, PayableDate);
        }
        if (hasAmountPerShare) {
          size += pb::CodedOutputStream.ComputeStringSize(4, AmountPerShare);
        }
        if (hasAdjustmentTime) {
          size += pb::CodedOutputStream.ComputeInt64Size(5, AdjustmentTime);
        }
        if (hasShareQty) {
          size += pb::CodedOutputStream.ComputeInt64Size(6, ShareQty);
        }
        if (hasTotal) {
          size += pb::CodedOutputStream.ComputeStringSize(7, Total);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static CashDividendPayment ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static CashDividendPayment ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static CashDividendPayment ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static CashDividendPayment ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static CashDividendPayment ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static CashDividendPayment ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static CashDividendPayment ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static CashDividendPayment ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static CashDividendPayment ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static CashDividendPayment ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private CashDividendPayment MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(CashDividendPayment prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<CashDividendPayment, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(CashDividendPayment cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private CashDividendPayment result;
      
      private CashDividendPayment PrepareBuilder() {
        if (resultIsReadOnly) {
          CashDividendPayment original = result;
          result = new CashDividendPayment();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override CashDividendPayment MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::dke.tradesim.protobuf.CashDividendPayment.Descriptor; }
      }
      
      public override CashDividendPayment DefaultInstanceForType {
        get { return global::dke.tradesim.protobuf.CashDividendPayment.DefaultInstance; }
      }
      
      public override CashDividendPayment BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is CashDividendPayment) {
          return MergeFrom((CashDividendPayment) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(CashDividendPayment other) {
        if (other == global::dke.tradesim.protobuf.CashDividendPayment.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasSecurityId) {
          SecurityId = other.SecurityId;
        }
        if (other.HasExDate) {
          ExDate = other.ExDate;
        }
        if (other.HasPayableDate) {
          PayableDate = other.PayableDate;
        }
        if (other.HasAmountPerShare) {
          AmountPerShare = other.AmountPerShare;
        }
        if (other.HasAdjustmentTime) {
          AdjustmentTime = other.AdjustmentTime;
        }
        if (other.HasShareQty) {
          ShareQty = other.ShareQty;
        }
        if (other.HasTotal) {
          Total = other.Total;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_cashDividendPaymentFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _cashDividendPaymentFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasSecurityId = input.ReadInt64(ref result.securityId_);
              break;
            }
            case 16: {
              result.hasExDate = input.ReadInt64(ref result.exDate_);
              break;
            }
            case 24: {
              result.hasPayableDate = input.ReadInt64(ref result.payableDate_);
              break;
            }
            case 34: {
              result.hasAmountPerShare = input.ReadString(ref result.amountPerShare_);
              break;
            }
            case 40: {
              result.hasAdjustmentTime = input.ReadInt64(ref result.adjustmentTime_);
              break;
            }
            case 48: {
              result.hasShareQty = input.ReadInt64(ref result.shareQty_);
              break;
            }
            case 58: {
              result.hasTotal = input.ReadString(ref result.total_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasSecurityId {
        get { return result.hasSecurityId; }
      }
      public long SecurityId {
        get { return result.SecurityId; }
        set { SetSecurityId(value); }
      }
      public Builder SetSecurityId(long value) {
        PrepareBuilder();
        result.hasSecurityId = true;
        result.securityId_ = value;
        return this;
      }
      public Builder ClearSecurityId() {
        PrepareBuilder();
        result.hasSecurityId = false;
        result.securityId_ = 0L;
        return this;
      }
      
      public bool HasExDate {
        get { return result.hasExDate; }
      }
      public long ExDate {
        get { return result.ExDate; }
        set { SetExDate(value); }
      }
      public Builder SetExDate(long value) {
        PrepareBuilder();
        result.hasExDate = true;
        result.exDate_ = value;
        return this;
      }
      public Builder ClearExDate() {
        PrepareBuilder();
        result.hasExDate = false;
        result.exDate_ = 0L;
        return this;
      }
      
      public bool HasPayableDate {
        get { return result.hasPayableDate; }
      }
      public long PayableDate {
        get { return result.PayableDate; }
        set { SetPayableDate(value); }
      }
      public Builder SetPayableDate(long value) {
        PrepareBuilder();
        result.hasPayableDate = true;
        result.payableDate_ = value;
        return this;
      }
      public Builder ClearPayableDate() {
        PrepareBuilder();
        result.hasPayableDate = false;
        result.payableDate_ = 0L;
        return this;
      }
      
      public bool HasAmountPerShare {
        get { return result.hasAmountPerShare; }
      }
      public string AmountPerShare {
        get { return result.AmountPerShare; }
        set { SetAmountPerShare(value); }
      }
      public Builder SetAmountPerShare(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasAmountPerShare = true;
        result.amountPerShare_ = value;
        return this;
      }
      public Builder ClearAmountPerShare() {
        PrepareBuilder();
        result.hasAmountPerShare = false;
        result.amountPerShare_ = "";
        return this;
      }
      
      public bool HasAdjustmentTime {
        get { return result.hasAdjustmentTime; }
      }
      public long AdjustmentTime {
        get { return result.AdjustmentTime; }
        set { SetAdjustmentTime(value); }
      }
      public Builder SetAdjustmentTime(long value) {
        PrepareBuilder();
        result.hasAdjustmentTime = true;
        result.adjustmentTime_ = value;
        return this;
      }
      public Builder ClearAdjustmentTime() {
        PrepareBuilder();
        result.hasAdjustmentTime = false;
        result.adjustmentTime_ = 0L;
        return this;
      }
      
      public bool HasShareQty {
        get { return result.hasShareQty; }
      }
      public long ShareQty {
        get { return result.ShareQty; }
        set { SetShareQty(value); }
      }
      public Builder SetShareQty(long value) {
        PrepareBuilder();
        result.hasShareQty = true;
        result.shareQty_ = value;
        return this;
      }
      public Builder ClearShareQty() {
        PrepareBuilder();
        result.hasShareQty = false;
        result.shareQty_ = 0L;
        return this;
      }
      
      public bool HasTotal {
        get { return result.hasTotal; }
      }
      public string Total {
        get { return result.Total; }
        set { SetTotal(value); }
      }
      public Builder SetTotal(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasTotal = true;
        result.total_ = value;
        return this;
      }
      public Builder ClearTotal() {
        PrepareBuilder();
        result.hasTotal = false;
        result.total_ = "";
        return this;
      }
    }
    static CashDividendPayment() {
      object.ReferenceEquals(global::dke.tradesim.protobuf.Tradesim.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class PortfolioValueLog : pb::GeneratedMessage<PortfolioValueLog, PortfolioValueLog.Builder> {
    private PortfolioValueLog() { }
    private static readonly PortfolioValueLog defaultInstance = new PortfolioValueLog().MakeReadOnly();
    private static readonly string[] _portfolioValueLogFieldNames = new string[] { "portfolioValues" };
    private static readonly uint[] _portfolioValueLogFieldTags = new uint[] { 10 };
    public static PortfolioValueLog DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override PortfolioValueLog DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override PortfolioValueLog ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::dke.tradesim.protobuf.Tradesim.internal__static_dke_tradesim_protobuf_PortfolioValueLog__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<PortfolioValueLog, PortfolioValueLog.Builder> InternalFieldAccessors {
      get { return global::dke.tradesim.protobuf.Tradesim.internal__static_dke_tradesim_protobuf_PortfolioValueLog__FieldAccessorTable; }
    }
    
    public const int PortfolioValuesFieldNumber = 1;
    private pbc::PopsicleList<global::dke.tradesim.protobuf.PortfolioValue> portfolioValues_ = new pbc::PopsicleList<global::dke.tradesim.protobuf.PortfolioValue>();
    public scg::IList<global::dke.tradesim.protobuf.PortfolioValue> PortfolioValuesList {
      get { return portfolioValues_; }
    }
    public int PortfolioValuesCount {
      get { return portfolioValues_.Count; }
    }
    public global::dke.tradesim.protobuf.PortfolioValue GetPortfolioValues(int index) {
      return portfolioValues_[index];
    }
    
    public override bool IsInitialized {
      get {
        foreach (global::dke.tradesim.protobuf.PortfolioValue element in PortfolioValuesList) {
          if (!element.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _portfolioValueLogFieldNames;
      if (portfolioValues_.Count > 0) {
        output.WriteMessageArray(1, field_names[0], portfolioValues_);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        foreach (global::dke.tradesim.protobuf.PortfolioValue element in PortfolioValuesList) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, element);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static PortfolioValueLog ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static PortfolioValueLog ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static PortfolioValueLog ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static PortfolioValueLog ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static PortfolioValueLog ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static PortfolioValueLog ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static PortfolioValueLog ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static PortfolioValueLog ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static PortfolioValueLog ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static PortfolioValueLog ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private PortfolioValueLog MakeReadOnly() {
      portfolioValues_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(PortfolioValueLog prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<PortfolioValueLog, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(PortfolioValueLog cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private PortfolioValueLog result;
      
      private PortfolioValueLog PrepareBuilder() {
        if (resultIsReadOnly) {
          PortfolioValueLog original = result;
          result = new PortfolioValueLog();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override PortfolioValueLog MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::dke.tradesim.protobuf.PortfolioValueLog.Descriptor; }
      }
      
      public override PortfolioValueLog DefaultInstanceForType {
        get { return global::dke.tradesim.protobuf.PortfolioValueLog.DefaultInstance; }
      }
      
      public override PortfolioValueLog BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is PortfolioValueLog) {
          return MergeFrom((PortfolioValueLog) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(PortfolioValueLog other) {
        if (other == global::dke.tradesim.protobuf.PortfolioValueLog.DefaultInstance) return this;
        PrepareBuilder();
        if (other.portfolioValues_.Count != 0) {
          result.portfolioValues_.Add(other.portfolioValues_);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_portfolioValueLogFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _portfolioValueLogFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              input.ReadMessageArray(tag, field_name, result.portfolioValues_, global::dke.tradesim.protobuf.PortfolioValue.DefaultInstance, extensionRegistry);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public pbc::IPopsicleList<global::dke.tradesim.protobuf.PortfolioValue> PortfolioValuesList {
        get { return PrepareBuilder().portfolioValues_; }
      }
      public int PortfolioValuesCount {
        get { return result.PortfolioValuesCount; }
      }
      public global::dke.tradesim.protobuf.PortfolioValue GetPortfolioValues(int index) {
        return result.GetPortfolioValues(index);
      }
      public Builder SetPortfolioValues(int index, global::dke.tradesim.protobuf.PortfolioValue value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.portfolioValues_[index] = value;
        return this;
      }
      public Builder SetPortfolioValues(int index, global::dke.tradesim.protobuf.PortfolioValue.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.portfolioValues_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddPortfolioValues(global::dke.tradesim.protobuf.PortfolioValue value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.portfolioValues_.Add(value);
        return this;
      }
      public Builder AddPortfolioValues(global::dke.tradesim.protobuf.PortfolioValue.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.portfolioValues_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangePortfolioValues(scg::IEnumerable<global::dke.tradesim.protobuf.PortfolioValue> values) {
        PrepareBuilder();
        result.portfolioValues_.Add(values);
        return this;
      }
      public Builder ClearPortfolioValues() {
        PrepareBuilder();
        result.portfolioValues_.Clear();
        return this;
      }
    }
    static PortfolioValueLog() {
      object.ReferenceEquals(global::dke.tradesim.protobuf.Tradesim.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class PortfolioValue : pb::GeneratedMessage<PortfolioValue, PortfolioValue.Builder> {
    private PortfolioValue() { }
    private static readonly PortfolioValue defaultInstance = new PortfolioValue().MakeReadOnly();
    private static readonly string[] _portfolioValueFieldNames = new string[] { "time", "value" };
    private static readonly uint[] _portfolioValueFieldTags = new uint[] { 8, 18 };
    public static PortfolioValue DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override PortfolioValue DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override PortfolioValue ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::dke.tradesim.protobuf.Tradesim.internal__static_dke_tradesim_protobuf_PortfolioValue__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<PortfolioValue, PortfolioValue.Builder> InternalFieldAccessors {
      get { return global::dke.tradesim.protobuf.Tradesim.internal__static_dke_tradesim_protobuf_PortfolioValue__FieldAccessorTable; }
    }
    
    public const int TimeFieldNumber = 1;
    private bool hasTime;
    private long time_;
    public bool HasTime {
      get { return hasTime; }
    }
    public long Time {
      get { return time_; }
    }
    
    public const int ValueFieldNumber = 2;
    private bool hasValue;
    private string value_ = "";
    public bool HasValue {
      get { return hasValue; }
    }
    public string Value {
      get { return value_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasTime) return false;
        if (!hasValue) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _portfolioValueFieldNames;
      if (hasTime) {
        output.WriteInt64(1, field_names[0], Time);
      }
      if (hasValue) {
        output.WriteString(2, field_names[1], Value);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasTime) {
          size += pb::CodedOutputStream.ComputeInt64Size(1, Time);
        }
        if (hasValue) {
          size += pb::CodedOutputStream.ComputeStringSize(2, Value);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static PortfolioValue ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static PortfolioValue ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static PortfolioValue ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static PortfolioValue ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static PortfolioValue ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static PortfolioValue ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static PortfolioValue ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static PortfolioValue ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static PortfolioValue ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static PortfolioValue ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private PortfolioValue MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(PortfolioValue prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<PortfolioValue, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(PortfolioValue cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private PortfolioValue result;
      
      private PortfolioValue PrepareBuilder() {
        if (resultIsReadOnly) {
          PortfolioValue original = result;
          result = new PortfolioValue();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override PortfolioValue MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::dke.tradesim.protobuf.PortfolioValue.Descriptor; }
      }
      
      public override PortfolioValue DefaultInstanceForType {
        get { return global::dke.tradesim.protobuf.PortfolioValue.DefaultInstance; }
      }
      
      public override PortfolioValue BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is PortfolioValue) {
          return MergeFrom((PortfolioValue) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(PortfolioValue other) {
        if (other == global::dke.tradesim.protobuf.PortfolioValue.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasTime) {
          Time = other.Time;
        }
        if (other.HasValue) {
          Value = other.Value;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_portfolioValueFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _portfolioValueFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasTime = input.ReadInt64(ref result.time_);
              break;
            }
            case 18: {
              result.hasValue = input.ReadString(ref result.value_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasTime {
        get { return result.hasTime; }
      }
      public long Time {
        get { return result.Time; }
        set { SetTime(value); }
      }
      public Builder SetTime(long value) {
        PrepareBuilder();
        result.hasTime = true;
        result.time_ = value;
        return this;
      }
      public Builder ClearTime() {
        PrepareBuilder();
        result.hasTime = false;
        result.time_ = 0L;
        return this;
      }
      
      public bool HasValue {
        get { return result.hasValue; }
      }
      public string Value {
        get { return result.Value; }
        set { SetValue(value); }
      }
      public Builder SetValue(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasValue = true;
        result.value_ = value;
        return this;
      }
      public Builder ClearValue() {
        PrepareBuilder();
        result.hasValue = false;
        result.value_ = "";
        return this;
      }
    }
    static PortfolioValue() {
      object.ReferenceEquals(global::dke.tradesim.protobuf.Tradesim.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class FinancialStatement : pb::GeneratedMessage<FinancialStatement, FinancialStatement.Builder> {
    private FinancialStatement() { }
    private static readonly FinancialStatement defaultInstance = new FinancialStatement().MakeReadOnly();
    private static readonly string[] _financialStatementFieldNames = new string[] { "lineItems" };
    private static readonly uint[] _financialStatementFieldTags = new uint[] { 10 };
    public static FinancialStatement DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override FinancialStatement DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override FinancialStatement ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::dke.tradesim.protobuf.Tradesim.internal__static_dke_tradesim_protobuf_FinancialStatement__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<FinancialStatement, FinancialStatement.Builder> InternalFieldAccessors {
      get { return global::dke.tradesim.protobuf.Tradesim.internal__static_dke_tradesim_protobuf_FinancialStatement__FieldAccessorTable; }
    }
    
    public const int LineItemsFieldNumber = 1;
    private pbc::PopsicleList<global::dke.tradesim.protobuf.StatementLineItem> lineItems_ = new pbc::PopsicleList<global::dke.tradesim.protobuf.StatementLineItem>();
    public scg::IList<global::dke.tradesim.protobuf.StatementLineItem> LineItemsList {
      get { return lineItems_; }
    }
    public int LineItemsCount {
      get { return lineItems_.Count; }
    }
    public global::dke.tradesim.protobuf.StatementLineItem GetLineItems(int index) {
      return lineItems_[index];
    }
    
    public override bool IsInitialized {
      get {
        foreach (global::dke.tradesim.protobuf.StatementLineItem element in LineItemsList) {
          if (!element.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _financialStatementFieldNames;
      if (lineItems_.Count > 0) {
        output.WriteMessageArray(1, field_names[0], lineItems_);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        foreach (global::dke.tradesim.protobuf.StatementLineItem element in LineItemsList) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, element);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static FinancialStatement ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static FinancialStatement ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static FinancialStatement ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static FinancialStatement ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static FinancialStatement ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static FinancialStatement ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static FinancialStatement ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static FinancialStatement ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static FinancialStatement ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static FinancialStatement ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private FinancialStatement MakeReadOnly() {
      lineItems_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(FinancialStatement prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<FinancialStatement, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(FinancialStatement cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private FinancialStatement result;
      
      private FinancialStatement PrepareBuilder() {
        if (resultIsReadOnly) {
          FinancialStatement original = result;
          result = new FinancialStatement();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override FinancialStatement MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::dke.tradesim.protobuf.FinancialStatement.Descriptor; }
      }
      
      public override FinancialStatement DefaultInstanceForType {
        get { return global::dke.tradesim.protobuf.FinancialStatement.DefaultInstance; }
      }
      
      public override FinancialStatement BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is FinancialStatement) {
          return MergeFrom((FinancialStatement) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(FinancialStatement other) {
        if (other == global::dke.tradesim.protobuf.FinancialStatement.DefaultInstance) return this;
        PrepareBuilder();
        if (other.lineItems_.Count != 0) {
          result.lineItems_.Add(other.lineItems_);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_financialStatementFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _financialStatementFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              input.ReadMessageArray(tag, field_name, result.lineItems_, global::dke.tradesim.protobuf.StatementLineItem.DefaultInstance, extensionRegistry);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public pbc::IPopsicleList<global::dke.tradesim.protobuf.StatementLineItem> LineItemsList {
        get { return PrepareBuilder().lineItems_; }
      }
      public int LineItemsCount {
        get { return result.LineItemsCount; }
      }
      public global::dke.tradesim.protobuf.StatementLineItem GetLineItems(int index) {
        return result.GetLineItems(index);
      }
      public Builder SetLineItems(int index, global::dke.tradesim.protobuf.StatementLineItem value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.lineItems_[index] = value;
        return this;
      }
      public Builder SetLineItems(int index, global::dke.tradesim.protobuf.StatementLineItem.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.lineItems_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddLineItems(global::dke.tradesim.protobuf.StatementLineItem value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.lineItems_.Add(value);
        return this;
      }
      public Builder AddLineItems(global::dke.tradesim.protobuf.StatementLineItem.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.lineItems_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeLineItems(scg::IEnumerable<global::dke.tradesim.protobuf.StatementLineItem> values) {
        PrepareBuilder();
        result.lineItems_.Add(values);
        return this;
      }
      public Builder ClearLineItems() {
        PrepareBuilder();
        result.lineItems_.Clear();
        return this;
      }
    }
    static FinancialStatement() {
      object.ReferenceEquals(global::dke.tradesim.protobuf.Tradesim.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class StatementLineItem : pb::GeneratedMessage<StatementLineItem, StatementLineItem.Builder> {
    private StatementLineItem() { }
    private static readonly StatementLineItem defaultInstance = new StatementLineItem().MakeReadOnly();
    private static readonly string[] _statementLineItemFieldNames = new string[] { "attribute", "type", "value" };
    private static readonly uint[] _statementLineItemFieldTags = new uint[] { 18, 8, 26 };
    public static StatementLineItem DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override StatementLineItem DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override StatementLineItem ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::dke.tradesim.protobuf.Tradesim.internal__static_dke_tradesim_protobuf_StatementLineItem__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<StatementLineItem, StatementLineItem.Builder> InternalFieldAccessors {
      get { return global::dke.tradesim.protobuf.Tradesim.internal__static_dke_tradesim_protobuf_StatementLineItem__FieldAccessorTable; }
    }
    
    #region Nested types
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public static partial class Types {
      public enum Type {
        String = 0,
        Decimal = 1,
      }
      
    }
    #endregion
    
    public const int TypeFieldNumber = 1;
    private bool hasType;
    private global::dke.tradesim.protobuf.StatementLineItem.Types.Type type_ = global::dke.tradesim.protobuf.StatementLineItem.Types.Type.String;
    public bool HasType {
      get { return hasType; }
    }
    public global::dke.tradesim.protobuf.StatementLineItem.Types.Type Type {
      get { return type_; }
    }
    
    public const int AttributeFieldNumber = 2;
    private bool hasAttribute;
    private string attribute_ = "";
    public bool HasAttribute {
      get { return hasAttribute; }
    }
    public string Attribute {
      get { return attribute_; }
    }
    
    public const int ValueFieldNumber = 3;
    private bool hasValue;
    private string value_ = "";
    public bool HasValue {
      get { return hasValue; }
    }
    public string Value {
      get { return value_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasType) return false;
        if (!hasAttribute) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _statementLineItemFieldNames;
      if (hasType) {
        output.WriteEnum(1, field_names[1], (int) Type, Type);
      }
      if (hasAttribute) {
        output.WriteString(2, field_names[0], Attribute);
      }
      if (hasValue) {
        output.WriteString(3, field_names[2], Value);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasType) {
          size += pb::CodedOutputStream.ComputeEnumSize(1, (int) Type);
        }
        if (hasAttribute) {
          size += pb::CodedOutputStream.ComputeStringSize(2, Attribute);
        }
        if (hasValue) {
          size += pb::CodedOutputStream.ComputeStringSize(3, Value);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static StatementLineItem ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static StatementLineItem ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static StatementLineItem ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static StatementLineItem ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static StatementLineItem ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static StatementLineItem ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static StatementLineItem ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static StatementLineItem ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static StatementLineItem ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static StatementLineItem ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private StatementLineItem MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(StatementLineItem prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<StatementLineItem, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(StatementLineItem cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private StatementLineItem result;
      
      private StatementLineItem PrepareBuilder() {
        if (resultIsReadOnly) {
          StatementLineItem original = result;
          result = new StatementLineItem();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override StatementLineItem MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::dke.tradesim.protobuf.StatementLineItem.Descriptor; }
      }
      
      public override StatementLineItem DefaultInstanceForType {
        get { return global::dke.tradesim.protobuf.StatementLineItem.DefaultInstance; }
      }
      
      public override StatementLineItem BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is StatementLineItem) {
          return MergeFrom((StatementLineItem) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(StatementLineItem other) {
        if (other == global::dke.tradesim.protobuf.StatementLineItem.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasType) {
          Type = other.Type;
        }
        if (other.HasAttribute) {
          Attribute = other.Attribute;
        }
        if (other.HasValue) {
          Value = other.Value;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_statementLineItemFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _statementLineItemFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              object unknown;
              if(input.ReadEnum(ref result.type_, out unknown)) {
                result.hasType = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(1, (ulong)(int)unknown);
              }
              break;
            }
            case 18: {
              result.hasAttribute = input.ReadString(ref result.attribute_);
              break;
            }
            case 26: {
              result.hasValue = input.ReadString(ref result.value_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasType {
       get { return result.hasType; }
      }
      public global::dke.tradesim.protobuf.StatementLineItem.Types.Type Type {
        get { return result.Type; }
        set { SetType(value); }
      }
      public Builder SetType(global::dke.tradesim.protobuf.StatementLineItem.Types.Type value) {
        PrepareBuilder();
        result.hasType = true;
        result.type_ = value;
        return this;
      }
      public Builder ClearType() {
        PrepareBuilder();
        result.hasType = false;
        result.type_ = global::dke.tradesim.protobuf.StatementLineItem.Types.Type.String;
        return this;
      }
      
      public bool HasAttribute {
        get { return result.hasAttribute; }
      }
      public string Attribute {
        get { return result.Attribute; }
        set { SetAttribute(value); }
      }
      public Builder SetAttribute(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasAttribute = true;
        result.attribute_ = value;
        return this;
      }
      public Builder ClearAttribute() {
        PrepareBuilder();
        result.hasAttribute = false;
        result.attribute_ = "";
        return this;
      }
      
      public bool HasValue {
        get { return result.hasValue; }
      }
      public string Value {
        get { return result.Value; }
        set { SetValue(value); }
      }
      public Builder SetValue(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasValue = true;
        result.value_ = value;
        return this;
      }
      public Builder ClearValue() {
        PrepareBuilder();
        result.hasValue = false;
        result.value_ = "";
        return this;
      }
    }
    static StatementLineItem() {
      object.ReferenceEquals(global::dke.tradesim.protobuf.Tradesim.Descriptor, null);
    }
  }
  
  #endregion
  
}

#endregion Designer generated code
